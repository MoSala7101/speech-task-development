/*******************************
 * Most of this module functions
 * was generated by ChatGPT 3   
 ******************************/
/**
 * Converts an audio Blob to a WAV Blob.
 * @param {AudioContext} audioContext - The AudioContext instance.
 * @param {Blob} blob - The audio Blob to convert.
 * @returns {Promise<Blob>} A promise that resolves to a WAV Blob.
 */
async function convertBlobToWav(audioContext, blob) {
    try {
        const arrayBuffer = await blob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        const monoAudioBuffer = downmixToMono(audioContext, audioBuffer);
        return audioBufferToWav(monoAudioBuffer);
    } catch (error) {
        console.error("Error converting Blob to WAV:", error);
    }
}

/**
 * Converts an AudioBuffer to a WAV Blob.
 * @param {AudioBuffer} buffer - The AudioBuffer to convert.
 * @returns {Blob} The resulting WAV Blob.
 */
function audioBufferToWav(buffer) {
    const numOfChannels = buffer.numberOfChannels,
        length = buffer.length * numOfChannels * 2 + 44,
        result = new DataView(new ArrayBuffer(length)),
        channels = [],
        sampleRate = buffer.sampleRate;
    let offset = 0,
        pos = 0;

    function setUint16(data) {
        result.setUint16(pos, data, true);
        pos += 2;
    }

    function setUint32(data) {
        result.setUint32(pos, data, true);
        pos += 4;
    }

    setUint32(0x46464952); // RIFF identifier
    setUint32(length - 8); // file length minus RIFF identifier length and file description length
    setUint32(0x45564157); // RIFF type

    setUint32(0x20746d66); // format chunk identifier
    setUint32(16); // format chunk length
    setUint16(1); // sample format (raw)
    setUint16(numOfChannels); // channel count
    setUint32(sampleRate); // sample rate
    setUint32(sampleRate * numOfChannels * 2); // byte rate (sample rate * block align)
    setUint16(numOfChannels * 2); // block align (channel count * bytes per sample)
    setUint16(16); // bits per sample

    setUint32(0x61746164); // data chunk identifier
    setUint32(length - pos - 4); // data chunk length

    for (let i = 0; i < buffer.numberOfChannels; i++) {
        channels.push(buffer.getChannelData(i));
    }

    while (pos < length) {
        for (let i = 0; i < numOfChannels; i++) {
            const sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp
            result.setInt16(pos, sample < 0 ? sample * 0x8000 : sample * 0x7fff, true); // convert to PCM
            pos += 2;
        }
        offset++;
    }

    return new Blob([result], { type: "audio/wav" });
}

/**
 * Converts a Blob to a Base64-encoded string.
 * @param {AudioContext} audioContext - The AudioContext instance.
 * @param {Blob} blob - The Blob to convert.
 * @returns {Promise<string>} A promise that resolves to a Base64-encoded string.
 */
async function blobToBase64(audioContext, blob) {
    const wavBlob = await convertBlobToWav(audioContext, blob);
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            const base64data = reader.result.split(",")[1];
            resolve(base64data);
        };
        reader.onerror = reject;
        reader.readAsDataURL(wavBlob);
    });
}

/**
 * Downmixes a multi-channel AudioBuffer to a mono AudioBuffer.
 * @param {AudioContext} audioContext - The AudioContext instance.
 * @param {AudioBuffer} buffer - The AudioBuffer to downmix.
 * @returns {AudioBuffer} The resulting mono AudioBuffer.
 */
function downmixToMono(audioContext, buffer) {
    const numberOfChannels = buffer.numberOfChannels;
    const length = buffer.length;
    const sampleRate = buffer.sampleRate;

    const monoBuffer = audioContext.createBuffer(1, length, sampleRate);
    const monoData = monoBuffer.getChannelData(0);

    for (let i = 0; i < length; i++) {
        let sum = 0;
        for (let channel = 0; channel < numberOfChannels; channel++) {
            sum += buffer.getChannelData(channel)[i];
        }
        monoData[i] = sum / numberOfChannels;
    }

    return monoBuffer;
}

module.exports = { blobToBase64 };
